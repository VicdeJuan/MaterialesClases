
\newcommand{\fullAnalisisESO}[1]{
\input{#1}
\mydominio
\myptscorte
\mysimetria
\mysigno
\myasintotas
\mygrafo
\newpage
}

\newcommand{\fullAnalisisBach}[1]{
\input{#1}
\mycontinuidadyderivabilidad
\mydominio
\myasintotas
\myptscorte
\mysimetria
\mymonotonia
\mycurvatura
\mygrafo
\newpage
}


\newcommand{\fullAsintotas}[1]{
\input{#1}
\mydominio
%\mysimetria
%\myptscorte
\myasintotas
%\mymonotonia
%\mygrafo
\newpage
}


\newcommand{\mycontinuidadyderivabilidad}{
    Es una función \sagestr{Tipo} y, por tanto, continua y derivable en todo su dominio.
}

\newcommand{\mydominio}{
\paragraph{Dominio}

\begin{dmath*}
    \sagestr{dominion(f=f,maketext=true)}
\end{dmath*}
}

\newcommand{\mysimetria}{
\subparagraph{Simetría}

\ifverbose
    Para estudiar la simetría de una función calculamos $f(-x)$ y comparamos con $f(x)$. 
    %
    En este caso:
\fi

\[f(-x) = \sage{latex(f(-x))}\]

¿Es igual a f(x) o a -f(x)? \sagestr{simetria(f)}

}

\newcommand{\myptscorte}{
    
\subparagraph{Puntos de corte con los ejes}

\textit{\textbf{Eje X}
}\ifverbose
Para calcular los puntos de corte de la función con el eje x resolvemos la ecuación $f(x) = 0$ cuya solución es: 
\\

\else 
$f(x) = 0\rightarrow $
\fi
\sagestr{puntosEjeX(func = f)} 

\textit{\textbf{Eje Y}}
\ifverbose
Para calcular los puntos de corte de la función con el eje y calculamos $f(0)$. 
%
En este caso:
\fi
\sagestr{puntosEjeY(func = f)}

}

\newcommand{\myasintotas}{
\paragraph{Asíntotas}
\subparagraph{Asíntotas verticales}


\ifverbose
Los posibles puntos en los que la función puede tener una asíntota vertical son aquellos en los que se anula el denominador. 
%
Por ello calculamos:
%
\[\sagestr{latex(f.denominator())} = 0 \]
\fi

\sagestr{asintotesV(f = f,den = f.denominator(),AV = AV)}



\subparagraph{Asíntotas horizontales u oblícuas}

\ifverbose
Las asíntotas horizontales y oblicuas nos dan la información acerca de la tendencia de la función en $-\infty$ y en $+\infty$.

Para calcular las asíntotas, necesitamos calcular el límite de la función tanto en $+\infty$ como en $-\infty$:
\fi

\[\lim_{x\mapsto \pm\infty} \sagestr{latex(f(x))} \]

\sagestr{asintotesHO(f = f,AH=AH,AO = AO)}


}


\newcommand{\mymonotonia}{
\paragraph{Monotonía}
	
$f'(x) = \sagestr{latex(diff(f(x),x,1).full_simplify())}$

Calculamos los puntos críticos, aquellos en los que $f'(x) = 0$

\sagestr{solveDerivadaNula(f=f,sols=ptsCrit,onlyReal=True)}


Añadimos a estos puntos aquellos en los que la función primitiva no exista y aquellos puntos en los que la función derivada no exista, si hay alguno. En este caso, 
%
\sagestr{ptsFrontera(f=f,ptscrit=ptsCrit,recta=recta,derivada_too=true)}

\sagestr{estudiarSignoDiff(f)}
}

\newcommand{\mycurvatura}{
\paragraph{Curvatura}
    


$f''(x) = \sagestr{latex(diff(diff(f(x),x,1),x,1).full_simplify())}$

Calculamos los puntos críticos, aquellos en los que $f''(x) = 0$

\sagestr{solveDerivadaNula(f=diff(f,x,1),sols=ptsCrit,onlyReal=True)}


Añadimos a estos puntos aquellos en los que la función primitiva o la primera derivada no existan, si hay alguno. En este caso, 
%
\sagestr{ptsFrontera(f=f,ptscrit=ptsCrit,recta=recta,derivada_too=true)}

\sagestr{estudiarSignoSegundaDerivada(f)}
}


\newcommand{\mysigno}{
\paragraph{Signo de la función}

\ifverbose
Dividimos la recta real con los puntos de corte con el eje $X$ y aquellos puntos de discontinuidad, en este caso, los que anulen el denominador.
\fi

\sagestr{estudiarSigno(f)}


}

\newcommand{\mygrafo}{
\paragraph{Gráfica de la función}
\ifverbose
En azul se marcan las asíntotas verticales, en rojo las horizontales y en morado las oblícuas.
\fi
\begin{figure}
    \begin{center}
        \sageplot{_myplot(f,AH=uniq(AH),AV=uniq(AV),AO=AO)}
    \end{center}
\caption{Gráfica de la función.}
\end{figure}
}




\begin{sagesilent}

from datetime import datetime
import logging

logging.basicConfig(filename='logs/'+str(datetime.now())+'.log',level=logging.DEBUG)
logging.debug('This message should go to the log file')
logging.info('So should this')
logging.warning('And this, too')

#Variables auxiliares necesarias
AV=[]
AH=[]
AO=[]
ptsCrit=[]
recta=[]
min=[]
max=[]

epsilon = 0.0000001



# Definición de las funciones

## Función para devolver un número sencillo entre 2 valores, que pueden ser infinitos.
# Input: j,k los 2 valores.
def random_between(j,k):
 if ((j==-Infinity) and (k == Infinity)):
  return 0

 if (j==-Infinity):
  return int(k-2)

 if (k==Infinity):
  return int(j+2)

 if (j < 0 and k>0):
  return 0

 if (j < 1 and k>1):
  return 1


 if (k-j>=2):
  return int(random()*(k-j-1))+j+1
 else:
  return round((k+j)/2.0,2)

#Resuelve los puntos de discontinuidad de la función.
def ptsDiscontinuidad(f):
    intervalos_dominio = dominion(f,false)
    logging.info("log : funcion ptsDiscontinuidad: dominio: "+str(intervalos_dominio))
    retval = []
    for ip in list(intervalos_dominio.complement()):
        if ip.is_point():
            retval.append(ip.lower())
    logging.info("log : funcion ptsDiscontinuidad: valor de retorno: " + str(retval))
    return retval

def _emptylist(aux):
    [aux.pop() for a in xrange(len(aux))]
    
#### Sage dice que limit(log(x),x=0,dir="minus") = Infinity. Esta función corrige esto:
# funcion: la funcion
# v: valor
# lado: "+" o "-"

def limit_lateral(funcion,v,lado):


    if lado == "+":
        _dir="plus"
        _test_val = v+epsilon
    elif lado == "-":
        _dir="minus"
        _test_val = v-epsilon
    else:
        logging.info("Error grave")
        _dir="whaaaat"
    

    if imag(funcion(_test_val)) != 0:
        return None
    else:
        return limit(funcion(x),x=v,dir=_dir)

## Función para calcular las asíntotas verticales de la función.
#Input:
# f: función
# den: denominador de la función en caso de haberlo.
# boolean log: tieneLog 
# AV: array vacío para rellenar
def asintotesV(f,den,AV):
    logging.info("funcion asintotesV: asíntotas recibidas: "+str(AV))
    _emptylist(AV)
    logging.info("funcion asintotesV: asíntotas vaciadas: "+str(AV))
    den0 = ptsDiscontinuidad(f=f)

    r=""
    k=0

    if (Verbose == 1):
        r+= "Soluciones: "
        for i in den0:
            r+="$x_"+str(k)+"="+latex(i)+" $;\\quad"
            k+=1
        if (den0 == []):
            r+= "No tiene soluciones reales"


    argsLog = getArgsLog(f)
    hasLog = len(argsLog)


    if (hasLog > 0):
        _log0 = []
        
        for arg in argsLog:
            [_log0.append(a) for a in solve(arg == 0 , x , solution_dict=True)]
            if not arg.denominator().is_constant():
                [_log0.append(a) for a in solve(arg.denominator() == 0 , x , solution_dict=True)]                

        logging.info(_log0)
        log0 = [a[x] for a in _log0 if imag(a[x])==0]  

        if (Verbose == 1):
            r+= "\\paragraph{Atención: } Como la función es un logaritmo, podríamos tener una asíntota vertical (ya que $\\displaystyle\\lim_{x\\mapsto 0^+} \\log(x) = -\infty$). Vamos a comprobarlo.\\\\"

            r+= "Para ello, calculamos los puntos en los que se haga 0 o $\pm\\infty$ el interior del logaritmo .\\\\"

        
            r+= "En este caso:"

        for arg in argsLog:
            r+= "\\[ "+latex(arg)+"= 0 \\]"

        r+= "Soluciones: "
        intervalos_dominio = dominion(f,false)
        logging.info("funcion asintotesV: dominio: " + str(intervalos_dominio))
        NoCandidates=[]
        for i in log0:
            if (i+epsilon in intervalos_dominio) or (i-epsilon in intervalos_dominio):
                r+="$x_"+str(k)+"="+latex(i)+" $;\\quad"
                k+=1
            
                if not i in den0:
                    den0.append(i)
            else:   
                NoCandidates.append([k,i])
                r+="$x_"+str(k)+"="+latex(i)+" $;\\quad"                
            
        if (log0 == []):
            r+= "No tiene soluciones reales"
        elif len(NoCandidates) > 0:
            r+= "\\\\De estas soluciones, "
            for a in NoCandidates:
                r+="$x_"+str(a[0])+"="+latex(i)+" $;\\quad"                
            r+= "no son candidatos a asíntota, puesto que ninguno de los 2 límites laterales existe."
            


    if (den0 == []):
        r+= "\\paragraph{La función no tiene A.V.}"

    for x0 in den0:
        r+= "\\paragraph{Asintota en $x ="
        r+= latex(x0)+"$}"

        ld = limit_lateral(f(x),x0,"+")
        li = limit_lateral(f(x),x0,"-")
        

        if (Verbose==1): 
            r+="Calculamos"
        r+= "\[\\lim_{x\\mapsto " + latex(x0) + "} " + latex(f(x)) + " = \\left\\{\\begin{array}{l} \\displaystyle\\lim_{x\\mapsto " + latex(x0) + "^{+}} " + latex(f(x)) + " = " + ___my_latex(ld) + " \\\\\\\\\\displaystyle\\lim_{x\\mapsto " + latex(x0) + "^{-}} " + latex(f(x)) + " = " + ___my_latex(li) + " \\\\\\end{array}\\right.\] "
        if ld != None and li != None:
            if (abs(li) == Infinity and abs(ld) == Infinity and sign(li) == sign(ld)):
                r+= "\n La recta x =" + latex(x0) + " es una \\textbf{asíntota vertical} de f(x)"
                AV.append(x0)
            elif (abs(li) == Infinity and abs(ld) == Infinity and sign(li) != sign(ld)):
                AV.append(x0)
                if (Verbose == 1):
                    r+= "\n Aunque el límite no exista (porque los límites laterales son diferentes), su magnitud sigue siendo infinita por ambos lados, por lo que la recta x = $" + latex(x0) + "$ es una \\textbf{asíntota vertical} de f(x)"
                else:
                    r+= "\n $x = " + latex(x0) + "$ es \\textbf{A.V.} de f(x)"
        elif ld == None and li == None:
            r+= "\n \\textbf{No hay asíntota vertical} en $x="+latex(x0)+"$."
        elif ld == None:
            if (abs(li) == Infinity):
                r += "\n $x = " + latex(x0) + "$ es \\textbf{A.V.} de f(x) por la izquierda."
                AV.append(x0)
        elif li == None :
            if (abs(ld) == Infinity):
                r += "\n $x = " + latex(x0) + "$ es \\textbf{A.V.} de f(x) por la derecha."
                AV.append(x0)
        else:
            r+= "\n \\textbf{No hay asíntota vertical} en $x="+latex(x0)+"$."
    AV=uniq(AV)
    logging.info("asintotesV: AV to ret: "+str(AV))
    return r

###Función para escribir latex de None como \nexists, para asegurar compatibilidad con la función limit_lateral.
def ___my_latex(value):
    if value==None:
        return "\\nexists"
    else:
        return latex(value)

## Función para calcular las asíntotas horizontales u oblicuas.
#Input:
# f: función

def asintotesHO(f,AH,AO):
    _emptylist(AH)
    _emptylist(AO)
    r=""
    ###Gnapa, que deberíamos arreglar:

    infsToCalcAsintotes = []
    intervalos_dominio = dominion(f,false)

    if 9999999999 in intervalos_dominio:
        infsToCalcAsintotes.append(Infinity)
    else:
        r+= "\\paragraph{No existe el límite de la función en $\\infty$:}"

    if -9999999999 in intervalos_dominio:
        infsToCalcAsintotes.append(-Infinity)
    else:
        r+= "\\paragraph{No existe el límite de la función en $-\\infty$:}"

        
    if len(infsToCalcAsintotes) == 0:
        r+= "La función no puede tener asíntotas horizontal por no estar definida en $\\pm\\infty$"
    
    for infty in infsToCalcAsintotes:
        if (Verbose == 1):
            r+= "\\paragraph{Límite de la función en $"+latex(infty)+"$:}"
        else:
            r+= "\\paragraph{$"+latex(infty)+"$:}"
        ld=limit(f, x=infty)  

        r+= "\[\\lim_{x\\mapsto "+latex(infty)+"}" + latex(f(x)) + "= ... = "+latex(ld)+"\]"    

        if (not (abs(ld) == Infinity)): # HORIZONTAL
            AH.append(ld)
            if (Verbose == 1):
                r+= "En $"+latex(infty)
                r+= "$ f(x) tiene una \\textbf{asíntota horizontal} en $y = "+latex(ld)+"$."
            else:
                r+= "$y = "+latex(ld) +" $ es una \\textbf{A.H.} de f(x)"

        else: # OBLICUA
            if (Verbose == 1):
                r+= "Como el límite obtenido es de magnitud infinita la función no tiene asíntota horizontal, pero puede tener una asíntota oblícua. Para saber si tiene una asíntota oblícua calculamos: "
            else:
                r+= "No tiene horizontal. ¿Oblícua?"

            m=limit(f/x,x=infty)
            r+= "\[m=\\lim_{x\\mapsto "+latex(infty)+"} \\frac{f(x)}{x} = \\lim_{x\\mapsto "+latex(infty)+"} \\frac{"+latex(f(x))+"}{x}=\\lim_{x\\mapsto "+latex(infty)+"} "+latex(f(x)/x)+" = ... = "+latex(m)+"\]"
            if (abs(m) != Infinity and m != 0):
                if (Verbose == 1):
                    r+= "        En este caso tenemos m=$"+latex(m)+"$ por lo que sí hay asíntota oblícua. Calculamos n:"
                r+= "    \[n= \\lim_{x\\mapsto "+latex(infty)+"} f(x) - m·x = \\lim_{x\\mapsto "+latex(infty)+"}\\left("+latex(f(x))+"-"+latex(m)+"x \\right) = \\lim_{x\\mapsto "+latex(infty)+"}"+latex(f(x)-m*x)+" = "+ limit(f-m*x,x=infty)+"\]"
                _n = limit(f-m*x,x=infty)
                n=_n
                y=m*x+n
                r+= "En $"+latex(infty)+"$, f(x) tiene una \\textbf{asíntota oblícua} en $y="+latex(y)+"$."
                AO.append(m*x+n)
            else:
                if (Verbose == 1):
                    r+= "En este caso, tenemos $m="+latex(m)+"$ por lo que \\textbf{no hay asíntota} oblícua (ni horizontal)."
                else:
                    r+= "\\textbf{No hay A.O. ni A.H.}"
    AH=uniq(AH)
    return r

# Estudio de la simetría de la función.
def simetria(f):
    if (f(x) == f(-x)):
        if (Verbose == 1):
            return "Sí, a f(x), entonces la función es par."
        else:
            return "Sí, $\\Rightarrow$ par"
    elif (f(x) == - f(-x)):
        if (Verbose == 1):
            return "Sí, a -f(x) entonces la función es impar."
        else:
            return "Sí, $\\Rightarrow$ impar"
    else:
        if (Verbose == 1):
            return "No, entonces la función no tiene simetría respecto del eje Y."
        else:
            return "No, $\\Rightarrow$ ninguna simetría"

###### Estudio de los puntos de corte
def puntosEjeX(func):
    r=""
    __roots = solve(func(x)==0,x,solution_dict=True,explicit_solutions=True)
    _roots = [a[x] for a in __roots if imag(a[x])==0]
    for i in xrange(len(_roots)):
        r+="$x_"+str(i)+" = "+latex(_roots[i])+"\\to \\left("+latex(_roots[i])+",0\\right)$;\\quad"
    if (_roots == []):
        r += "No tiene solución."
    if Verbose:
        r+= "\\\\\\textit{Obs: Sólo puede haber puntos de corte en puntos del dominio.}"
    return r

def puntosEjeY(func):
    intervalos_dominio = dominion(f,false)
    if 0 in intervalos_dominio:
        return "$f(0) = " + latex(func(0)) + "$, con lo que la gráfica corta en $\\left(0,"+latex(func(0)) + "\\right)$ al eje Y."   
    else:
        return  "No existe f(0)."    
    


############### Monotonía

# Funcion para calcular los puntos que anulan la derivada.
# Devuelve: cadena de texto con el codigo LaTeX.
# Recibe:
#   f: funcion
#   list sols: lista en la que escribir las soluciones (sobreescribe lo que tenga. Se recomienda pasar una lista vacia) 
#   boolean onlyReal: para calcular solo soluciones reales.

def solveDerivadaNula(f,sols,onlyReal):
    logging.info("solveDerivadaNula" +  str(f))
    intervalos_dominio = dominion(f,false)
    _sols = solve(diff(f(x))==0,x,solution_dict=True,explicit_solutions=True)
    if onlyReal:
        sols = [a[x] for a in _sols if imag(a[x])==0]
    else: 
        sols=_sols



    logging.info("\t solveDerivadaNula de " + str(f))
    logging.info("\t solveDerivadaNula dominio " + str(intervalos_dominio))
        
    i=0
    retval=""
    NoCandidates = []
    for r in sols:
        logging.info("\t solveDerivadaNula r in sols: r= " + str(r))
        retval += "$x_"+str(i)+" = "+latex(r.full_simplify())+"$;\\quad"
        if not r in intervalos_dominio:
            logging.info("\t solveDerivadaNula: "+str(r)+" no del dominio")
            NoCandidates.append([i,r])
        i+=1
    
    if len(NoCandidates) > 0:
        retval += "\\\\De estas soluciones, "
        for a in NoCandidates:
            retval +="$x_"+str(a[0])+"="+latex(a[1].full_simplify())+" $;\\quad"
        
        retval += "no son válidas porque no pertenecen al dominio."
    

    if (sols == []):
        retval += "No tiene soluciones reales."


    return retval


def ptsFrontera(f,ptscrit,recta,derivada_too):
    logging.info("funcion ptsFrontera")
    puntosFrontera = flatten([flatten(ptsDiscontinuidad(f=f)),flatten(ptscrit)])
    if derivada_too:
        ___pts = ptsDiscontinuidad(f=diff(f(x),x,1))
        if ___pts != []:
            puntosFrontera.append(___pts)

    puntosFrontera = uniq(flatten(puntosFrontera))
    
    # En lugar de -infinity, hay que poner el extremo mínimo del dominio.
    #recta=[-Infinity]
    intervalos_dominio = dominion(f,false)
    recta = [intervalos_dominio[0].lower()]

    i=0
    r=""
    for p in puntosFrontera:
        r+= "$x_"+str(i)+"="+latex(p)+"$;\\quad"
        i+=1

    if len(puntosFrontera) == 0:
        r += " no hay."

    for p in puntosFrontera:
        recta.append(p)
    recta.append(+Infinity)
    recta=sorted(uniq(recta))
    return r

# Construye una cadena de texto los intervalos formados por una lista de puntos frontera.
def intervalos(recta):
    logging.info("funcion intervalos: intervalos de recta: "+str(recta))
    r = ""
    for i in xrange(len(recta)-1):
        r += "$\\left("+latex(recta[i])+","+latex(recta[i+1])+"\\right)$;\\quad"  
    return r


# Estudia el signo de la función dada la función y los puntos frontera.
def estudiarSigno(f):
    logging.info("estudiarSigno")
    intervalos_dominio = dominion(f,false)
    recta= [intervalos_dominio[0].lower(),intervalos_dominio[0].upper()]
    for a in _getRealroots(f):
        recta.append(a)
    for a in ptsDiscontinuidad(f=f):
        recta.append(a)
    recta=sorted(recta) 

    retval = "\\begin{itemize}"
    for i in xrange(len(recta)-1):
        rval=random_between(recta[i],recta[i+1])
        retval += "\\item $\\left("+latex(recta[i])+","+latex(recta[i+1])+"\\right)$:"
        if (Verbose == 1):
            retval += " Tomamos, por ejemplo, $f("+latex(rval)+") = "+latex(round(f(rval),3))+"...$  y miramos su signo:" 
        else:
            retval += "$f("+latex(rval)+") = "+latex(round(f(rval),3)) +"$"
        actual=sign(f(rval))
        if actual==1: 
            if (Verbose == 1):
                retval += "Positivo"  
            else:
                retval += "+"
        else:
            if (Verbose == 1):
                retval += "Negativo"
            else:
                retval += "-"

    retval += "\\end{itemize}"
    return retval

# Enumera una lista de valores entre llaves.
def printlist(m):
    retval = "\\{"
    for i in range(m):
    	retval += "x_" + str(i) +  " = " + latex(m[i]) + ";\\quad"
    return retval+"\\}"



def _getRealroots(f):
 logging.info("_getRealroots de " + str(f))
 __roots = solve(f==0,x,solution_dict=True)
 logging.info("\t soluciones: "+str(__roots))
 _roots = []
 for a in __roots:
    #logging.info("t estudiando "+str(a[x]))
    if (a[x]).has(x):
        logging.info("\t es expresión, calculamos solución numérica..."+str(a) + " [x]-> "+str(a[x]))        
        sol = find_root(f,-Infinity,Infinity)
        logging.info("\t encontrada solucion: "+str(sol))
        _roots.append(sol)
    else:
        logging.info("\t no es expresión ")
        if imag(a[x]) == 0:
            _roots.append(a[x].full_simplify())
 logging.info("\t soluciones to return: " + str(_roots))
 return _roots



### Estudia el signo de la función derivada, tanto para la curvatura, como para la monotonía.
# Devuelve codigo LaTeX
# Recibe:
# f: función
# min: lista
# max: lista
# boolean curvatura: false si buscamos estudiar la monotnía. True para estudiar curvatura.
def _f_sign_monot(recta,f,min,max,curvatura):
 _emptylist(min)
 _emptylist(max)
 df=diff(f,x,1)
 ddf = diff(df,x,1)

 recta=[-Infinity,Infinity]
 
 if curvatura:
    # Los puntos que marcan extremos de intervalos son:
    #       los valores que anulan la segunda derivada, 
    #       los puntos de discontinuidad de la derivada 
    #       los puntos de discontinuidad de la función.
    for a in _getRealroots(ddf):
        recta.append(a)
    for a in ptsDiscontinuidad(f=df):
        recta.append(a)
    for a in ptsDiscontinuidad(f=f):
        recta.append(a)
    recta=sorted(recta) 
 else:
    for a in _getRealroots(df):
        recta.append(a)
    for a in ptsDiscontinuidad(f=f):
        recta.append(a)
    recta=sorted(recta) 
 
 retval = "Los intervalos a estudiar son: "+latex(intervalos(recta))
 
 prev=0
 actual=0
 if curvatura:
    fun = "f''"
    g = ddf # La función a utilizar es la segunda derivada.
 else:
    fun = "f"
    g = df # La función a estudiar es la derivada.
 retval += "\\begin{itemize}"
 for i in xrange(len(recta)-1):
  rval=random_between(recta[i],recta[i+1])
  retval += "\\item $\\left("+latex(recta[i])+","+latex(recta[i+1])+"\\right)$:"
  if (Verbose == 1):
   retval += " Tomamos, por ejemplo, "+fun+"($"+latex(rval)+") = "+latex(round(g(rval),3))+"...$  y miramos su signo:" 
  else:
   retval += fun + "($"+latex(rval)+") = "+latex(round(g(rval),3)) +"$"
  prev=actual
  actual=sign(g(rval))
  if actual==1: 
   if (Verbose == 1):
    if curvatura:
        retval += "Positivo, por lo que la función es \\textbf{convexa} en este intervalo."
    else:
        retval += "Positivo, por lo que la función \\textbf{crece} en este intervalo."  
   else:
    if curvatura:
        retval += "Positivo, $\\Rightarrow$ \\textbf{convexa}."
    else:  
        retval += "Positivo $\\Rightarrow$ crece."
  else:
   if (Verbose == 1):
    if curvatura:
        retval += "Negativo, por lo que la función es \\textbf{cóncava} en este intervalo."
    else:
        retval += "Negativo, por lo que la función \\textbf{decrece} en este intervalo."
   else:

    if curvatura:
        retval += "Negativo, \\textbf{cóncava}."
    else:
        retval += "Negativo $\\Rightarrow$ decrece."


 
 return retval+"\\end{itemize}"
 

### Estudia el signo de la función derivada, tanto para la curvatura, como para la monotonía.
# Devuelve codigo LaTeX en modo tabla
# Recibe:
# f: función
# min: lista
# max: lista
# boolean curvatura: false si buscamos estudiar la monotnía. True para estudiar curvatura.
def _f_sign_monot_tabla(recta,f,min,max,curvatura):

## IDEAS PARA MEJORAR. Poner los "&" al final, para poder poner \\hline entre las filas de las tablas.
 _emptylist(min)
 _emptylist(max)
 df=diff(f,x,1)
 ddf = diff(df,x,1)

 intervalos_dominio = dominion(f,false)

 _min = intervalos_dominio[0].lower()
 _max = list(intervalos_dominio)[-1].upper()
 recta= [_min,_max]
 
 logging.info("_f_sign_monot_tabla: \n log:\t f:"+str(f) + "\n log:\t curvatura: "+str(curvatura) + "\n log: \t recta: "+str(recta)+"\n log: \t"+str(intervalos_dominio))
 
 if curvatura:
    # Los puntos que marcan extremos de intervalos son:
    #       los valores que anulan la segunda derivada, 
    #       los puntos de discontinuidad de la derivada 
    #       los puntos de discontinuidad de la función.
    for a in _getRealroots(ddf):
        if a in intervalos_dominio:
            recta.append(a)
    for a in ptsDiscontinuidad(f=df):
        recta.append(a)
    for a in ptsDiscontinuidad(f=f):
        recta.append(a)
 else:
    logging.info("\t solo monotonia" )
    __roots = _getRealroots(df) 
    logging.info("raíces df: \t "+str(__roots))
    for a in __roots:
        if a in intervalos_dominio:
            recta.append(a)
    for a in ptsDiscontinuidad(f=f):
        recta.append(a)

 recta=sorted(uniq(recta))


 logging.info("_f_sign_monot_tabla: recta: "+str(recta))
 lista_intervalos = intervalos(recta)

 if curvatura:
    fun = "f''"
    g = ddf # La función a utilizar es la segunda derivada.
 else:
    fun = "f'"
    g = df # La función a estudiar es la derivada.

 retval = "Los intervalos a estudiar son: "+latex(lista_intervalos)
 

 __label = "estudio" + str(random_between(1,1000000)) + str(random_between(1,1000000)) + str(random_between(1,1000000))
 retval += "Ver tabla \\ref{"+__label+"}, con el estudio de "+fun+"(x)"


 prev=0
 actual=1
 
 logging.info("_f_sign_monot_tabla: comenzamos a construir la tabla")
 # Construimos la tabla, con tantas columnas como intervalos+1, para poner la función
 retval +="\\newline\\begin{table}[h!]\\centering\\begin{tabular}{"+"c|"*(len(recta))+"}"
 # Construimos la primera fila de la tabla
 
 
 for i in xrange(len(recta)-1):
  retval += "& $\\left("+latex(recta[i])+","+latex(recta[i+1])+"\\right)$"

 retval += "\\\\ "
 
 conclusiones=[]
 # Construimos la segunda fila de la tabla:
 for i in xrange(len(recta)-1):
  logging.info("\t\t _f_sign_monot_tabla: estudiando intervalo: " + str([recta[i],recta[i+1]])) 
  rval=random_between(recta[i],recta[i+1])
  retval += "&"+fun + "($"+latex(rval)+") = "+latex(round(g(rval),3)) +"$"
  if sign(g(rval)) == 1:
    if curvatura:
        conclusiones.append("Convexa")
    else: 
        conclusiones.append("Creciente")
    retval += "$>0$"
  else:
    if curvatura:
        conclusiones.append("Cóncava")
    else:
        conclusiones.append("Decreciente")
    retval += "$<0$"
  

  # Guardar en la lista los mínimos.
  toadd = recta[i]
  prev = actual
  actual = sign(g(rval))
  logging.info("\t\t _f_sign_monot_tabla - valor: "+str(rval))
  logging.info("\t\t _f_sign_monot_tabla - signo actual: "+str(actual))
  logging.info("\t\t _f_sign_monot_tabla - signo prev: "+str(prev))
  if not i == 0:
      if prev!=actual and actual == -1 and toadd in intervalos_dominio:
        max.append(toadd)
      if prev!=actual and actual == 1 and toadd in intervalos_dominio:
        min.append(toadd)

 retval += "\\\\"

 # Incluimos última fila de la tabla:
 for c in conclusiones:
    retval += "&" + c

 #Fin del bucle
 logging.info("\t\t _f_sign_monot_tabla: minlist: "+str(min))
 logging.info("\t\t _f_sign_monot_tabla: maxlist: "+str(max))

 retval += "\\end{tabular}\\caption{Estudio del signo de $" + fun + "(x)=" + latex(g.full_simplify()) + "$}\\label{"+__label+"}\\end{table}"
 
 if not curvatura:
    retval += "\\paragraph{Lista de máximos y mínimos:} obtenidos estudiando la monotonía a ambos lados de cada puntos, siempre que el punto esté en el dominio."
    if Verbose == 1:
        retval+="\\subparagraph{Criterio:} \\begin{itemize}\\item \\textit{Si por un lado crece, y por el otro decrece, entonces será un mínimo.}\\item \\textit{Si por un lado decrece, y por el otro crece, será un máximo.}\\item \\textit{Si a ambos lados tiene el mismo comportamiento, no será un máximo ni un mínimo}\\end{itemize}"

    retval +="\\begin{itemize}"
    retval += "\\item"
    if max == []:
        retval += "La función no tiene ningún máximo."
    elif len(max) == 1:
        retval += "El punto $x=" + latex(max[0]) + "$ es un máximo de la función.\\\\" 
    else:
        retval += "Los puntos $" + printlist(max) + "$ son máximos de la función.\\\\" 
    retval += "\\item"
    if min == []:
        retval += "La función no tiene ningún mínimo."
    elif len(min) == 1:
        retval += "El punto $x=" + latex(min[0]) + "$ es un mínimo de la función.\\\\"
    else:
        retval += "Los puntos $" + printlist(min) + "$ son mínimos de la función.\\\\"
    retval += "\\end{itemize}"  
 return retval 

def estudiarSignoDiff(f):
 if Verbose == 1: #BUG
    _retval = _f_sign_monot_tabla(recta,f,min,max,false)
 else:   
    _retval = _f_sign_monot_tabla(recta,f,min,max,false)
 
 return _retval

def estudiarSignoSegundaDerivada(f):
 if Verbose == 1:#BUG
    _retval = _f_sign_monot_tabla(recta,f,min,max,true)
 else:   
    _retval = _f_sign_monot_tabla(recta,f,min,max,true)
 
 return _retval


## Function str ismin(f,x0).
## f: second derivate of the function to study.
## x0: value to check if it is maximum.
## return 	string with the answer.
def ismin(f,x0):
 val = f(x0)
 retval = "f("+str(x0)+") = "+str(f(x0))
 if val<0:
  retval += "<0 por lo que hay un máximo relativo en "+str(x0)
 elif val>0:
  retval += ">0 por lo que hay un mínimo relativo en "+str(x0)
 else:
  retval += "No podemos determinar si se trata de un máximo o un mínimo de esta manera" 
 return retval
 

###### Devuelve los intervalos solución de una inecuación.
# Función auxiliar:

def __simpleInecToInterval(s):
    logging.info("__simpleInecToInterval de s: " + str(s))
    ineqOperators = {
        (x<3).operator():"<",
        (x>3).operator():">",
        (x<=3).operator():"<=",
        (x>=3).operator():">="
    }    
    left = s.lhs()
    right = s.rhs()
    operator = ineqOperators[s.operator()]

    logging.info("\t left,right,operator"+str(left)+","+str(right)+","+str(operator))
    if left.is_numeric() or left.is_infinity():
        logging.info("\t left: "+str(left))
        num = left
    elif right.is_numeric() or right.is_infinity():
        logging.info("\t right: "+str(right))
        num = right
    else:
        num = "Error grave"
        

    if operator == "<":
        return "(-\\infty,"+str(num)+")"
    elif operator == "<=":
        return "(-\\infty,"+str(num)+"]"
    elif operator == ">":
        return "("+str(num)+",\\infty)"
    elif operator == ">=":
        return "["+str(num)+",\\infty)"
    else:
        return "Error grave"        

# tosolve: inecuación a pasarle a solve direcamente. 
#   Ejemplo: x^2-9 >= 0
def __getIntervalsFromIneq(tosolve,intervals):
    logging.info("__getIntervalsFromIneq")
    logging.info("\t tosolve: "+str(tosolve))
    logging.info("\t intervals: "+str(intervals))
    solutions = tosolve.solve(x)
    logging.info("\t solucions: "+str(solutions))

    __aux = []
    for i in solutions:
        if type(i) == type(x+1):
            logging.info("\t is expression")
            __aux.append(RealSet(i))
        else:
            logging.info("\t is not expression")
            __aux.append(RealSet(i[0]))

    logging.info("\t __aux - intervals: "+str(__aux))
    
    intervals.append(reduce(RealSet.union,__aux))
    logging.info("\t intervals: "+str(intervals))
    if len(solutions) > 1:
        openpar = "\\left"
        closepar = "\\right"
    else:
        openpar = ""
        closepar = ""

    __aux = []
    for i in solutions:
        if type(i) == type(x+1):
            logging.info("\t is expression")
            __aux.append(__simpleInecToInterval(i))
            logging.info("terminado __simpleInecToInterval")
        else:
            logging.info("\t is not expression")
            __aux.append(__simpleInecToInterval(i[0]))
            logging.info("terminado __simpleInecToInterval")

    logging.info("\t __aux - sols: "+str(__aux)) 
    __intervals__ = " \\cup ".join(__aux)
    return openpar + "("+ __intervals__ + closepar + ")"



## Función auxiliar recursiva para obtener todos los radicandos que tiene una función:
# f: función
# num: contador
def __hasRt_aux(f,num):
    retval = []
    if len(f.operands()) == 2 and (sage.symbolic.expression.is_Expression(f.operands()) == false ):
        if not f.operands()[1].is_integer() and f.operands()[1].is_numeric():
            retval.append(f.operands()[0])
            
    for _op in f.operands():
        l = __hasRt_aux(_op,num+1)
        if not l == []:
            retval.append(l)
    return retval

def getRadicandos(f):
    return flatten(__hasRt_aux(f,0))


## Función auxiliar recursiva para obtener todos los argumentos de los logaritmos que tenga la función
# f: función
# num: contador
def __hasLog_aux(f,num):
    retval = []
    if len(f.operands()) == 1 and f.operator() == (log(x).operator()):
        retval.append(f.operands()[0])
            
    for _op in f.operands():
        l = __hasLog_aux(_op,num+1)
        if not l == []:
            retval.append(l)
    return retval

def getArgsLog(f):
    return flatten(__hasLog_aux(f,0))



## Devuelve en texto el dominio de la función. 
# f: función
# intervalos_dominio: conjunto vacío en la que rellenar los valores del dominio.
def dominion(f,maketext):
    intervalos_dominio = RealSet(0,0)
    logging.info("log (funcion dominion): funcion - "+str(f))


    
    argsLog = getArgsLog(f)
    hasLog = len(argsLog)
    isLog = hasLog
    ## Rutina para conocer si la función tiene alguna raíz:
    radicandos = getRadicandos(f)
    hasRt = len(radicandos)

    
    hasDen = f.denominator() == 1

    doms = ""
    denominator=f.denominator()
    intervals=[]
    intersect = 0
    if not denominator.is_constant():
        s0=latex(denominator)
        __solutions = [a[x] for a in solve(f.denominator() == 0,x,solution_dict=True,domain='real') if imag(a[x])==0]   
        s1=",".join([str(a) for a in __solutions ])
        doms += "\\{x\\in\\real \\tq "+s0+" \\neq 0 \\} = \\real - \{"+ s1 + "\}\n"
        
        for _s in __solutions:
            intervals.append(RealSet(-Infinity,_s)+RealSet(_s,Infinity))
        intersect+=1
        
    else:
        logging.info("log (funcion dominion): denominador de " + str(f) + " es constante")    

    
    if hasLog:
        if hasLog==1:
            base=e
        else:
            base=hasLog
        #Gnapa para arreglar

        f
        for argument in argsLog: 
            s0=latex(argument)
            
            if intersect > 0:
                doms += "\\cap"
            intersect+=1

            doms += "\\{x\\in\\real \\tq "+s0+" > 0 \\} "
            doms+=""  
        # Resolvemos inecuaciones
        doms+="} = {"

        _to_domain = [__getIntervalsFromIneq(argument>0,intervals) for argument in argsLog]
        doms += "\\cap".join(_to_domain)


        
    if hasRt:
        #Gnapa para arreglar
        for argument in radicandos: 
            s0=latex(argument)
            logging.info(argument)
            #s1=",".join(str(a[x]) for a in solve(argument>=0,x,solution_dict=True))
            
            if intersect > 0:
                doms += "\\cap"
            intersect+=1

            doms += "\\{x\\in\\real \\tq "+s0+" > 0 \\} "
            doms+=""  
        # Resolvemos inecuaciones
        doms+="} = {"
        _to_domain = [__getIntervalsFromIneq(argument>=0,intervals) for argument in radicandos]

        doms += "\\cap".join(_to_domain)
        
              
    if doms == "":
        doms = "\\real"
        
    logging.info("log (funcion dominion): FN: dominion\n\t Asignacion intervals=intervalos_dominio")
    logging.info("log (funcion dominion): intervals" + str(intervals))
    logging.info("log (funcion dominion): intervalos_dominio " + str(intervalos_dominio))
    if len(intervals) == 0:
        __dominio = RealSet(-oo,oo)
    else:
        __dominio = reduce(RealSet.intersection,intervals) 

    intervalos_dominio = intervalos_dominio.union(__dominio)
    logging.info("log (funcion dominion): dominio preseignacion" + str(__dominio ))
    logging.info("log (funcion dominion): dominio posteignacion" + str(intervalos_dominio))
    
    logging.info("log (funcion dominion) variable global"+str(intervalos_dominio))
    
    if maketext:
        return "D(f) = {"+doms + "} = {" + str(__dominio).replace("oo","\\infty").replace("+","\\cup").replace("\\cup\\infty","+\\infty") + "}"
    else:
        return intervalos_dominio

### Función para pintar las gráficas.
# f: función
# int list AV: lista de puntos en los que hay una asíntota vertical.
# int list AH: lista de puntos en los que hay una asintota horizontal.
# EXPR AO: ecuación de la asíntota oblícua y=mx+n
def _myplot(f,AV,AH,AO):
 logging.info("_myplot: f: " + str(f))
 logging.info("_myplot: AV: " + str(AV))
 logging.info("_myplot: AH: " + str(AH))
 intervalos_dominio = dominion(f,false)
 discont=list(set(ptsDiscontinuidad(f=f)).difference(AV))
 xmin=-8
 xmax=8
 ymin=-10
 ymax=10
 c1=['blue','red','green','black','purple',colors]

 
 P=plot(f(x),xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax,figsize=6,plot_points=2500,legend_label="f(x)", axes_labels=['$x$','$y$'],exclude=discont,color='green')
 
 j=0
 for i in xrange(len(AV)):
  lab="x="+str(AV[i])
  v=AV[i]
  P+=line([(v,ymin),(v,ymax)],legend_label=lab,color='blue',linestyle='-')
  j=i
 for i in xrange(len(AH)):
  lab="y="+str(AH[i])
  h=AH[i]
  P+=line([(xmin,h),(xmax,h)],legend_label=lab,color='red',linestyle='-')
 for i in xrange(len(discont)):
  x0=discont[i]
  ld=limit(f(x),x=x0,dir="plus")
  
  P+=circle((x0,ld),0.2,facecolor='white',fill=True)
 if AO != []:
  P+=plot(AO,color='purple',xmin=xmin,xmax=xmax,ymin=ymin,ymax=ymax)
 return P
\end{sagesilent}


%%%%%%% Plot
